.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "FISH-LANGUAGE" "1" "Mar 25, 2023" "3.6" "fish-shell"
.sp
This document is a comprehensive overview of fish\(aqs scripting language.
.sp
For interactive features see \fI\%Interactive use\fP\&.
.SH SYNTAX OVERVIEW
.sp
Shells like fish are used by giving them commands. A command is executed by writing the name of the command followed by any arguments. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
echo hello world
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fI\%echo\fP command writes its arguments to the screen. In this example the output is \fBhello world\fP\&.
.sp
Everything in fish is done with commands. There are commands for repeating other commands, commands for assigning variables, commands for treating a group of commands as a single command, etc. All of these commands follow the same basic syntax.
.sp
Every program on your computer can be used as a command in fish. If the program file is located in one of the \fI\%PATH\fP directories, you can just type the name of the program to use it. Otherwise the whole filename, including the directory (like \fB/home/me/code/checkers/checkers\fP or \fB\&../checkers\fP) is required.
.sp
Here is a list of some useful commands:
.INDENT 0.0
.IP \(bu 2
\fI\%cd\fP: Change the current directory
.IP \(bu 2
\fBls\fP: List files and directories
.IP \(bu 2
\fBman\fP: Display a manual page \- try \fBman ls\fP to get help on your \(dqls\(dq command, or \fBman mv\fP to get information about \(dqmv\(dq.
.IP \(bu 2
\fBmv\fP: Move (rename) files
.IP \(bu 2
\fBcp\fP: Copy files
.IP \(bu 2
\fI\%open\fP: Open files with the default application associated with each filetype
.IP \(bu 2
\fBless\fP: Display the contents of files
.UNINDENT
.sp
Commands and arguments are separated by the space character \fB\(aq \(aq\fP\&. Every command ends with either a newline (by pressing the return key) or a semicolon \fB;\fP\&. Multiple commands can be written on the same line by separating them with semicolons.
.sp
A switch is a very common special type of argument. Switches almost always start with one or more hyphens \fB\-\fP and alter the way a command operates. For example, the \fBls\fP command usually lists the names of all files and directories in the current working directory. By using the \fB\-l\fP switch, the behavior of \fBls\fP is changed to not only display the filename, but also the size, permissions, owner, and modification time of each file.
.sp
Switches differ between commands and are usually documented on a command\(aqs manual page. There are some switches, however, that are common to most commands. For example, \fB\-\-help\fP will usually display a help text, \fB\-\-version\fP will usually display the command version, and \fB\-i\fP will often turn on interactive prompting before taking action. Try \fBman your\-command\-here\fP to get information on your command\(aqs switches.
.sp
So the basic idea of fish is the same as with other unix shells: It gets a commandline, runs \fI\%expansions\fP, and the result is then run as a command.
.SH TERMINOLOGY
.sp
Here we define some of the terms used on this page and throughout the rest of the fish documentation:
.INDENT 0.0
.IP \(bu 2
\fBArgument\fP: A parameter given to a command. In \fBecho foo\fP, the \(dqfoo\(dq is an argument.
.IP \(bu 2
\fBBuiltin\fP: A command that is implemented by the shell. Builtins are so closely tied to the operation of the shell that it is impossible to implement them as external commands. In \fBecho foo\fP, the \(dqecho\(dq is a builtin.
.IP \(bu 2
\fBCommand\fP: A program that the shell can run, or more specifically an external program that the shell runs in another process. External commands are provided on your system, as executable files. In \fBecho foo\fP the \(dqecho\(dq is a builtin command, in \fBcommand echo foo\fP the \(dqecho\(dq is an external command, provided by a file like /bin/echo.
.IP \(bu 2
\fBFunction\fP: A block of commands that can be called as if they were a single command. By using functions, it is possible to string together multiple simple commands into one more advanced command.
.IP \(bu 2
\fBJob\fP: A running pipeline or command.
.IP \(bu 2
\fBPipeline\fP: A set of commands strung together so that the output of one command is the input of the next command. \fBecho foo | grep foo\fP is a pipeline.
.IP \(bu 2
\fBRedirection\fP: An operation that changes one of the input or output streams associated with a job.
.IP \(bu 2
\fBSwitch\fP or \fBOption\fP: A special kind of argument that alters the behavior of a command. A switch almost always begins with one or two hyphens. In \fBecho \-n foo\fP the \(dq\-n\(dq is an option.
.UNINDENT
.SH QUOTES
.sp
Sometimes you want to give a command an argument that contains characters special to fish, like spaces or \fB$\fP or \fB*\fP\&. To do that, you can use quotes:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
rm \(dqmy file.txt\(dq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
to remove a file called \fBmy file.txt\fP instead of trying to remove two files, \fBmy\fP and \fBfile.txt\fP\&.
.sp
Fish understands two kinds of quotes: Single (\fB\(aq\fP) and double (\fB\(dq\fP), and both work slightly differently.
.sp
Between single quotes, fish performs no expansions. Between double quotes, fish only performs \fI\%variable expansion\fP and \fI\%command substitution\fP in the \fB$(command)\fP\&. No other kind of expansion (including \fI\%brace expansion\fP or parameter expansion) is performed, and escape sequences (for example, \fB\en\fP) are ignored. Within quotes, whitespace is not used to separate arguments, allowing quoted arguments to contain spaces.
.sp
The only meaningful escape sequences in single quotes are \fB\e\(aq\fP, which escapes a single quote and \fB\e\e\fP, which escapes the backslash symbol. The only meaningful escapes in double quotes are \fB\e\(dq\fP, which escapes a double quote, \fB\e$\fP, which escapes a dollar character, \fB\e\fP followed by a newline, which deletes the backslash and the newline, and \fB\e\e\fP, which escapes the backslash symbol.
.sp
Single quotes have no special meaning within double quotes and vice versa.
.sp
More examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
grep \(aqenabled)$\(aq foo.txt
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
searches for lines ending in \fBenabled)\fP in \fBfoo.txt\fP (the \fB$\fP is special to \fBgrep\fP: it matches the end of the line).
.INDENT 0.0
.TP
.B ::
apt install \(dqpostgres\-
.nf
*
.fi
\(dq
.UNINDENT
.sp
installs all packages with a name starting with \(dqpostgres\-\(dq, instead of looking through the current directory for files named \(dqpostgres\-something\(dq.
.SH ESCAPING CHARACTERS
.sp
Some characters cannot be written directly on the command line. For these characters, so\-called escape sequences are provided. These are:
.INDENT 0.0
.IP \(bu 2
\fB\ea\fP represents the alert character.
.IP \(bu 2
\fB\ee\fP represents the escape character.
.IP \(bu 2
\fB\ef\fP represents the form feed character.
.IP \(bu 2
\fB\en\fP represents a newline character.
.IP \(bu 2
\fB\er\fP represents the carriage return character.
.IP \(bu 2
\fB\et\fP represents the tab character.
.IP \(bu 2
\fB\ev\fP represents the vertical tab character.
.IP \(bu 2
\fB\exHH\fP or \fB\eXHH\fP, where \fBHH\fP is a hexadecimal number, represents a byte of data with the specified value. For example, \fB\ex9\fP is the tab character. If you are using a multibyte encoding, this can be used to enter invalid strings. Typically fish is run with the ASCII or UTF\-8 encoding, so anything up to \fB\eX7f\fP is an ASCII character.
.IP \(bu 2
\fB\eooo\fP, where \fBooo\fP is an octal number, represents the ASCII character with the specified value. For example, \fB\e011\fP is the tab character. The highest allowed value is \fB\e177\fP\&.
.IP \(bu 2
\fB\euXXXX\fP, where \fBXXXX\fP is a hexadecimal number, represents the 16\-bit Unicode character with the specified value. For example, \fB\eu9\fP is the tab character.
.IP \(bu 2
\fB\eUXXXXXXXX\fP, where \fBXXXXXXXX\fP is a hexadecimal number, represents the 32\-bit Unicode character with the specified value. For example, \fB\eU9\fP is the tab character. The highest allowed value is U10FFFF.
.IP \(bu 2
\fB\ecX\fP, where \fBX\fP is a letter of the alphabet, represents the control sequence generated by pressing the control key and the specified letter. For example, \fB\eci\fP is the tab character
.UNINDENT
.sp
Some characters have special meaning to the shell. For example, an apostrophe \fB\(aq\fP disables expansion (see \fI\%Quotes\fP). To tell the shell to treat these characters literally, escape them with a backslash. For example, the command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
echo \e\(aqhello world\e\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
outputs \fB\(aqhello world\(aq\fP (including the apostrophes), while the command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
echo \(aqhello world\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
outputs \fBhello world\fP (without the apostrophes). In the former case the shell treats the apostrophes as literal \fB\(aq\fP characters, while in the latter case it treats them as special expansion modifiers.
.sp
The special characters and their escape sequences are:
.INDENT 0.0
.IP \(bu 2
\fB\e\ \fP (backslash space) escapes the space character. This keeps the shell from splitting arguments on the escaped space.
.IP \(bu 2
\fB\e$\fP escapes the dollar character.
.IP \(bu 2
\fB\e\e\fP escapes the backslash character.
.IP \(bu 2
\fB\e*\fP escapes the star character.
.IP \(bu 2
\fB\e?\fP escapes the question mark character (this is not necessary if the \fBqmark\-noglob\fP \fI\%feature flag\fP is enabled).
.IP \(bu 2
\fB\e~\fP escapes the tilde character.
.IP \(bu 2
\fB\e#\fP escapes the hash character.
.IP \(bu 2
\fB\e(\fP escapes the left parenthesis character.
.IP \(bu 2
\fB\e)\fP escapes the right parenthesis character.
.IP \(bu 2
\fB\e{\fP escapes the left curly bracket character.
.IP \(bu 2
\fB\e}\fP escapes the right curly bracket character.
.IP \(bu 2
\fB\e[\fP escapes the left bracket character.
.IP \(bu 2
\fB\e]\fP escapes the right bracket character.
.IP \(bu 2
\fB\e<\fP escapes the less than character.
.IP \(bu 2
\fB\e>\fP escapes the more than character.
.IP \(bu 2
\fB\e&\fP escapes the ampersand character.
.IP \(bu 2
\fB\e|\fP escapes the vertical bar character.
.IP \(bu 2
\fB\e;\fP escapes the semicolon character.
.IP \(bu 2
\fB\e\(dq\fP escapes the quote character.
.IP \(bu 2
\fB\e\(aq\fP escapes the apostrophe character.
.UNINDENT
.sp
As a special case, \fB\e\fP immediately followed by a literal new line is a \(dqcontinuation\(dq and tells fish to ignore the line break and resume input at the start of the next line (without introducing any whitespace or terminating a token).
.SH INPUT/OUTPUT REDIRECTION
.sp
Most programs use three input/output (I/O) streams:
.INDENT 0.0
.IP \(bu 2
Standard input (stdin) for reading. Defaults to reading from the keyboard.
.IP \(bu 2
Standard output (stdout) for writing output. Defaults to writing to the screen.
.IP \(bu 2
Standard error (stderr) for writing errors and warnings. Defaults to writing to the screen.
.UNINDENT
.sp
Each stream has a number called the file descriptor (FD): 0 for stdin, 1 for stdout, and 2 for stderr.
.sp
The destination of a stream can be changed using something called \fIredirection\fP\&. For example, \fBecho hello > output.txt\fP, redirects the standard output of the \fBecho\fP command to a text file.
.INDENT 0.0
.IP \(bu 2
To read standard input from a file, use \fB<SOURCE_FILE\fP\&.
.IP \(bu 2
To write standard output to a file, use \fB>DESTINATION\fP\&.
.IP \(bu 2
To write standard error to a file, use \fB2>DESTINATION\fP\&. [1]
.IP \(bu 2
To append standard output to a file, use \fB>>DESTINATION_FILE\fP\&.
.IP \(bu 2
To append standard error to a file, use \fB2>>DESTINATION_FILE\fP\&.
.IP \(bu 2
To not overwrite (\(dqclobber\(dq) an existing file, use \fB>?DESTINATION\fP or \fB2>?DESTINATION\fP\&. This is known as the \(dqnoclobber\(dq redirection.
.UNINDENT
.sp
\fBDESTINATION\fP can be one of the following:
.INDENT 0.0
.IP \(bu 2
A filename to write the output to. Often \fB>/dev/null\fP to silence output by writing it to the special \(dqsinkhole\(dq file.
.IP \(bu 2
An ampersand (\fB&\fP) followed by the number of another file descriptor like \fB&2\fP for standard error. The output will be written to the destination descriptor.
.IP \(bu 2
An ampersand followed by a minus sign (\fB&\-\fP). The file descriptor will be closed. Note: This may cause the program to fail because its writes will be unsuccessful.
.UNINDENT
.sp
As a convenience, the redirection \fB&>\fP can be used to direct both stdout and stderr to the same destination. For example, \fBecho hello &> all_output.txt\fP redirects both stdout and stderr to the file \fBall_output.txt\fP\&. This is equivalent to \fBecho hello > all_output.txt 2>&1\fP\&.
.sp
Any arbitrary file descriptor can be used in a redirection by prefixing the redirection with the FD number.
.INDENT 0.0
.IP \(bu 2
To redirect the input of descriptor N, use \fBN<DESTINATION\fP\&.
.IP \(bu 2
To redirect the output of descriptor N, use \fBN>DESTINATION\fP\&.
.IP \(bu 2
To append the output of descriptor N to a file, use \fBN>>DESTINATION_FILE\fP\&.
.UNINDENT
.sp
For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Write \(gafoo\(ga\(aqs standard error (file descriptor 2)
# to a file called \(dqoutput.stderr\(dq:
foo 2> output.stderr

# if $num doesn\(aqt contain a number,
# this test will be false and print an error,
# so by ignoring the error we can be sure that we\(aqre dealing
# with a number in the \(dqif\(dq block:
if test \(dq$num\(dq \-gt 2 2>/dev/null
    # do things with $num as a number greater than 2
else
    # do things if $num is <= 2 or not a number
end

# Save \(gamake\(gas output in a file:
make &>/log

# Redirections stack and can be used with blocks:
begin
    echo stdout
    echo stderr >&2 # <\- this goes to stderr!
end >/dev/null # ignore stdout, so this prints \(dqstderr\(dq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It is an error to redirect a builtin, function, or block to a file descriptor above 2. However this is supported for external commands.
.IP [1] 5
Previous versions of fish also allowed specifying this as \fB^DESTINATION\fP, but that made another character special so it was deprecated and removed. See \fI\%feature flags\fP\&.
.SH PIPING
.sp
Another way to redirect streams is a \fIpipe\fP\&. A pipe connects streams with each other. Usually the standard output of one command is connected with the standard input of another. This is done by separating commands with the pipe character \fB|\fP\&. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cat foo.txt | head
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The command \fBcat foo.txt\fP sends the contents of \fBfoo.txt\fP to stdout. This output is provided as input for the \fBhead\fP program, which prints the first 10 lines of its input.
.sp
It is possible to pipe a different output file descriptor by prepending its FD number and the output redirect symbol to the pipe. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
make fish 2>| less
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
will attempt to build \fBfish\fP, and any errors will be shown using the \fBless\fP pager. [2]
.sp
As a convenience, the pipe \fB&|\fP redirects both stdout and stderr to the same process. This is different from bash, which uses \fB|&\fP\&.
.IP [2] 5
A \(dqpager\(dq here is a program that takes output and \(dqpaginates\(dq it. \fBless\fP doesn\(aqt just do pages, it allows arbitrary scrolling (even back!).
.SH JOB CONTROL
.sp
When you start a job in fish, fish itself will pause, and give control of the terminal to the program just started. Sometimes, you want to continue using the commandline, and have the job run in the background. To create a background job, append an \fB&\fP (ampersand) to your command. This will tell fish to run the job in the background. Background jobs are very useful when running programs that have a graphical user interface.
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
emacs &
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
will start the emacs text editor in the background. \fI\%fg\fP can be used to bring it into the foreground again when needed.
.sp
Most programs allow you to suspend the program\(aqs execution and return control to fish by pressing \fBControl\fP+\fBZ\fP (also referred to as \fB^Z\fP). Once back at the fish commandline, you can start other programs and do anything you want. If you then want you can go back to the suspended command by using the \fI\%fg\fP (foreground) command.
.sp
If you instead want to put a suspended job into the background, use the \fI\%bg\fP command.
.sp
To get a listing of all currently started jobs, use the \fI\%jobs\fP command.
These listed jobs can be removed with the \fI\%disown\fP command.
.sp
At the moment, functions cannot be started in the background. Functions that are stopped and then restarted in the background using the \fI\%bg\fP command will not execute correctly.
.sp
If the \fB&\fP character is followed by a non\-separating character, it is not interpreted as background operator. Separating characters are whitespace and the characters \fB;<>&|\fP\&.
.SH FUNCTIONS
.sp
Functions are programs written in the fish syntax. They group together various commands and their arguments using a single name.
.sp
For example, here\(aqs a simple function to list directories:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function ll
    ls \-l $argv
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The first line tells fish to define a function by the name of \fBll\fP, so it can be used by simply writing \fBll\fP on the commandline. The second line tells fish that the command \fBls \-l $argv\fP should be called when \fBll\fP is invoked. \fI\%$argv\fP is a \fI\%list variable\fP, which always contains all arguments sent to the function. In the example above, these are simply passed on to the \fBls\fP command. The \fBend\fP on the third line ends the definition.
.sp
Calling this as \fBll /tmp/\fP will end up running \fBls \-l /tmp/\fP, which will list the contents of /tmp.
.sp
This is a kind of function known as an \fI\%alias\fP\&.
.sp
Fish\(aqs prompt is also defined in a function, called \fI\%fish_prompt\fP\&. It is run when the prompt is about to be displayed and its output forms the prompt:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function fish_prompt
    # A simple prompt. Displays the current directory
    # (which fish stores in the $PWD variable)
    # and then a user symbol \- a \(aq►\(aq for a normal user and a \(aq#\(aq for root.
    set \-l user_char \(aq►\(aq
    if fish_is_root_user
        set user_char \(aq#\(aq
    end

    echo (set_color yellow)$PWD (set_color purple)$user_char
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To edit a function, you can use \fI\%funced\fP, and to save a function \fI\%funcsave\fP\&. This will store it in a function file that fish will \fI\%autoload\fP when needed.
.sp
The \fI\%functions\fP builtin can show a function\(aqs current definition (and \fI\%type\fP will also do if given a function).
.sp
For more information on functions, see the documentation for the \fI\%function\fP builtin.
.SS Defining aliases
.sp
One of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the \fBls\fP command to display colors. The switch for turning on colors on GNU systems is \fB\-\-color=auto\fP\&. An alias around \fBls\fP might look like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function ls
    command ls \-\-color=auto $argv
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
There are a few important things that need to be noted about aliases:
.INDENT 0.0
.IP \(bu 2
Always take care to add the \fI\%$argv\fP variable to the list of parameters to the wrapped command. This makes sure that if the user specifies any additional parameters to the function, they are passed on to the underlying command.
.IP \(bu 2
If the alias has the same name as the aliased command, you need to prefix the call to the program with \fBcommand\fP to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).
.UNINDENT
.sp
To easily create a function of this form, you can use the \fI\%alias\fP command. Unlike other shells, this just makes functions \- fish has no separate concept of an \(dqalias\(dq, we just use the word for a simple wrapping function like this. \fI\%alias\fP immediately creates a function. Consider using \fBalias \-\-save\fP or \fI\%funcsave\fP to save the created function into an autoload file instead of recreating the alias each time.
.sp
For an alternative, try \fI\%abbreviations\fP\&. These are words that are expanded while you type, instead of being actual functions inside the shell.
.SS Autoloading functions
.sp
Functions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:
.INDENT 0.0
.IP \(bu 2
An autoloaded function becomes available automatically to all running shells.
.IP \(bu 2
If the function definition is changed, all running shells will automatically reload the altered version, after a while.
.IP \(bu 2
Startup time and memory usage is improved, etc.
.UNINDENT
.sp
When fish needs to load a function, it searches through any directories in the \fI\%list variable\fP \fB$fish_function_path\fP for a file with a name consisting of the name of the function plus the suffix \fB\&.fish\fP and loads the first it finds.
.sp
For example if you try to execute something called \fBbanana\fP, fish will go through all directories in $fish_function_path looking for a file called \fBbanana.fish\fP and load the first one it finds.
.sp
By default \fB$fish_function_path\fP contains the following:
.INDENT 0.0
.IP \(bu 2
A directory for users to keep their own functions, usually \fB~/.config/fish/functions\fP (controlled by the \fBXDG_CONFIG_HOME\fP environment variable).
.IP \(bu 2
A directory for functions for all users on the system, usually \fB/etc/fish/functions\fP (really \fB$__fish_sysconfdir/functions\fP).
.IP \(bu 2
Directories for other software to put their own functions. These are in the directories under \fB$__fish_user_data_dir\fP (usually \fB~/.local/share/fish\fP, controlled by the \fBXDG_DATA_HOME\fP environment variable) and in the \fBXDG_DATA_DIRS\fP environment variable, in a subdirectory called \fBfish/vendor_functions.d\fP\&. The default value for \fBXDG_DATA_DIRS\fP is usually \fB/usr/share/fish/vendor_functions.d\fP and \fB/usr/local/share/fish/vendor_functions.d\fP\&.
.IP \(bu 2
The functions shipped with fish, usually installed in \fB/usr/share/fish/functions\fP (really \fB$__fish_data_dir/functions\fP).
.UNINDENT
.sp
If you are unsure, your functions probably belong in \fB~/.config/fish/functions\fP\&.
.sp
As we\(aqve explained, autoload files are loaded \fIby name\fP, so, while you can put multiple functions into one file, the file will only be loaded automatically once you try to execute the one that shares the name.
.sp
Autoloading also won\(aqt work for \fI\%event handlers\fP, since fish cannot know that a function is supposed to be executed when an event occurs when it hasn\(aqt yet loaded the function. See the \fI\%event handlers\fP section for more information.
.sp
If a file of the right name doesn\(aqt define the function, fish will not read other autoload files, instead it will go on to try builtins and finally commands. This allows masking a function defined later in $fish_function_path, e.g. if your administrator has put something into /etc/fish/functions that you want to skip.
.sp
If you are developing another program and want to install fish functions for it, install them to the \(dqvendor\(dq functions directory. As this path varies from system to system, you can use \fBpkgconfig\fP to discover it with the output of \fBpkg\-config \-\-variable functionsdir fish\fP\&. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.
.SH COMMENTS
.sp
Anything after a \fB#\fP until the end of the line is a comment. That means it\(aqs purely for the reader\(aqs benefit, fish ignores it.
.sp
This is useful to explain what and why you are doing something:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function ls
    # The function is called ls,
    # so we have to explicitly call \(gacommand ls\(ga to avoid calling ourselves.
    command ls \-\-color=auto $argv
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
There are no multiline comments. If you want to make a comment span multiple lines, simply start each line with a \fB#\fP\&.
.sp
Comments can also appear after a line like so:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set \-gx EDITOR emacs # I don\(aqt like vim.
.ft P
.fi
.UNINDENT
.UNINDENT
.SH CONDITIONS
.sp
Fish has some builtins that let you execute commands only if a specific criterion is met: \fI\%if\fP, \fI\%switch\fP, \fI\%and\fP and \fI\%or\fP, and also the familiar \fI\%&&/||\fP syntax.
.SS The \fBif\fP statement
.sp
The \fI\%if\fP statement runs a block of commands if the condition was true.
.sp
Like other shells, but unlike typical programming languages you might know, the condition here is a \fIcommand\fP\&. Fish runs it, and if it returns a true \fI\%exit status\fP (that\(aqs 0), the if\-block is run. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if test \-e /etc/os\-release
    cat /etc/os\-release
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This uses the \fI\%test\fP command to see if the file /etc/os\-release exists. If it does, it runs \fBcat\fP, which prints it on the screen.
.sp
Unlike other shells, the condition command just ends after the first job, there is no \fBthen\fP here. Combiners like \fBand\fP and \fBor\fP extend the condition.
.sp
\fBif\fP is commonly used with the \fI\%test\fP command that can check conditions.:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if test 5 \-gt 2
    echo \(dqYes, 5 is greater than 2\(dq
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBif\fP can also take \fBelse if\fP clauses with additional conditions and an  \fI\%else\fP clause that is executed when everything else was false:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if test \(dq$number\(dq \-gt 10
   echo Your number was greater than 10
else if test \(dq$number\(dq \-gt 5
   echo Your number was greater than 5
else if test \(dq$number\(dq \-gt 1
   echo Your number was greater than 1
else
   echo Your number was smaller or equal to 1
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fI\%not\fP keyword can be used to invert the status:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Just see if the file contains the string \(dqfish\(dq anywhere.
# This executes the \(gagrep\(ga command, which searches for a string,
# and if it finds it returns a status of 0.
# The \(ganot\(ga then turns 0 into 1 or anything else into 0.
# The \(ga\-q\(ga switch stops it from printing any matches.
if not grep \-q fish myanimals
    echo \(dqYou don\(aqt have fish!\(dq
else
    echo \(dqYou have fish!\(dq
end
.ft P
.fi
.UNINDENT
.UNINDENT
.SS The \fBswitch\fP statement
.sp
The \fI\%switch\fP command is used to execute one of possibly many blocks of commands depending on the value of a string. It can take multiple \fI\%case\fP blocks that are executed when the string matches. They can take \fI\%wildcards\fP\&. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
switch (uname)
case Linux
    echo Hi Tux!
case Darwin
    echo Hi Hexley!
case DragonFly \(aq*BSD\(aq
    echo Hi Beastie! # this also works for FreeBSD and NetBSD
case \(aq*\(aq
    echo Hi, stranger!
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Unlike other shells or programming languages, there is no fallthrough \- the first matching \fBcase\fP block is executed and then control jumps out of the \fBswitch\fP\&.
.SS Combiners (\fBand\fP / \fBor\fP / \fB&&\fP / \fB||\fP)
.sp
For simple checks, you can use combiners. \fI\%and\fP or \fB&&\fP run the second command if the first succeeded, while \fI\%or\fP or \fB||\fP run it if the first failed. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# $XDG_CONFIG_HOME is a standard place to store configuration.
# If it\(aqs not set applications should use ~/.config.
set \-q XDG_CONFIG_HOME; and set \-l configdir $XDG_CONFIG_HOME
or set \-l configdir ~/.config
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that combiners are \fIlazy\fP \- only the part that is necessary to determine the final status is run.
.sp
Compare:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if sleep 2; and false
    echo \(aqHow did I get here? This should be impossible\(aq
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
and:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if false; and sleep 2
    echo \(aqHow did I get here? This should be impossible\(aq
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
These do essentially the same thing, but the former takes 2 seconds longer because the \fBsleep\fP always needs to run.
.sp
Or you can have a case where it is necessary to stop early:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if command \-sq foo; and foo
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If this went on after seeing that the command \(dqfoo\(dq doesn\(aqt exist, it would try to run \fBfoo\fP and error because it wasn\(aqt found!
.sp
Combiners really just execute step\-by\-step, so it isn\(aqt recommended to build longer chains of them because they might do something you don\(aqt want. Consider:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
test \-e /etc/my.config
or echo \(dqOH NO WE NEED A CONFIG FILE\(dq
and return 1
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This will execute \fBreturn 1\fP also if the \fBtest\fP succeeded. This is because fish runs \fBtest \-e /etc/my.config\fP, sets $status to 0, then skips the \fBecho\fP, keeps $status at 0, and then executes the \fBreturn 1\fP because $status is still 0.
.sp
So if you have more complex conditions or want to run multiple things after something failed, consider using an \fI\%if\fP\&. Here that would be:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if not test \-e /etc/my.config
    echo \(dqOH NO WE NEED A CONFIG FILE\(dq
    return 1
end
.ft P
.fi
.UNINDENT
.UNINDENT
.SH LOOPS AND BLOCKS
.sp
Like most programming language, fish also has the familiar \fI\%while\fP and \fI\%for\fP loops.
.sp
\fBwhile\fP works like a repeated \fI\%if\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
while true
    echo Still running
    sleep 1
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
will print \(dqStill running\(dq once a second. You can abort it with ctrl\-c.
.sp
\fBfor\fP loops work like in other shells, which is more like python\(aqs for\-loops than e.g. C\(aqs:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
for file in *
    echo file: $file
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
will print each file in the current directory. The part after the \fBin\fP is just a list of arguments, so you can use any \fI\%expansions\fP there:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set moreanimals bird fox
for animal in {cat,}fish dog $moreanimals
   echo I like the $animal
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you need a list of numbers, you can use the \fBseq\fP command to create one:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
for i in (seq 1 5)
    echo $i
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fI\%break\fP is available to break out of a loop, and \fI\%continue\fP to jump to the next iteration.
.sp
\fI\%Input and output redirections\fP (including \fI\%pipes\fP) can also be applied to loops:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
while read \-l line
    echo line: $line
end < file
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In addition there\(aqs a \fI\%begin\fP block that just groups commands together so you can redirect to a block or use a new \fI\%variable scope\fP without any repetition:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
begin
   set \-l foo bar # this variable will only be available in this block!
end
.ft P
.fi
.UNINDENT
.UNINDENT
.SH PARAMETER EXPANSION
.sp
When fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:
.INDENT 0.0
.IP \(bu 2
\fI\%Wildcards\fP, to create filenames from patterns \- \fB*.jpg\fP
.IP \(bu 2
\fI\%Variable expansion\fP, to use the value of a variable \- \fB$HOME\fP
.IP \(bu 2
\fI\%Command substitution\fP, to use the output of another command \- \fB$(cat /path/to/file)\fP
.IP \(bu 2
\fI\%Brace expansion\fP, to write lists with common pre\- or suffixes in a shorter way \fB{/usr,}/bin\fP
.IP \(bu 2
\fI\%Tilde expansion\fP, to turn the \fB~\fP at the beginning of paths into the path to the home directory \fB~/bin\fP
.UNINDENT
.sp
Parameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.
.SS Wildcards (\(dqGlobbing\(dq)
.sp
When a parameter includes an \fI\%unquoted\fP \fB*\fP star (or \(dqasterisk\(dq) or a \fB?\fP question mark, fish uses it as a wildcard to match files.
.INDENT 0.0
.IP \(bu 2
\fB*\fP matches any number of characters (including zero) in a file name, not including \fB/\fP\&.
.IP \(bu 2
\fB**\fP matches any number of characters (including zero), and also descends into subdirectories. If \fB**\fP is a segment by itself, that segment may match zero times, for compatibility with other shells.
.IP \(bu 2
\fB?\fP can match any single character except \fB/\fP\&. This is deprecated and can be disabled via the \fBqmark\-noglob\fP \fI\%feature flag\fP, so \fB?\fP will just be an ordinary character.
.UNINDENT
.sp
Wildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings \(aq1\(aq \(aq5\(aq and \(aq12\(aq would be sorted like 1, 5, 12.
.sp
Hidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.
.sp
Examples:
.INDENT 0.0
.IP \(bu 2
\fBa*\fP matches any files beginning with an \(aqa\(aq in the current directory.
.IP \(bu 2
\fB**\fP matches any files and directories in the current directory and all of its subdirectories.
.IP \(bu 2
\fB~/.*\fP matches all hidden files (also known as \(dqdotfiles\(dq) and directories in your home directory.
.UNINDENT
.sp
For most commands, if any wildcard fails to expand, the command is not executed, \fI\%$status\fP is set to nonzero, and a warning is printed. This behavior is like what bash does with \fBshopt \-s failglob\fP\&. There are exceptions, namely \fI\%set\fP and \fI\%path\fP, overriding variables in \fI\%overrides\fP, \fI\%count\fP and \fI\%for\fP\&. Their globs will instead expand to zero arguments (so the command won\(aqt see them at all), like with \fBshopt \-s nullglob\fP in bash.
.sp
Examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# List the .foo files, or warns if there aren\(aqt any.
ls *.foo

# List the .foo files, if any.
set foos *.foo
if count $foos >/dev/null
    ls $foos
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Unlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like \fBapt install\fP that does the matching itself, you need to add quotes:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
apt install \(dqncurses\-*\(dq
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Variable expansion
.sp
One of the most important expansions in fish is the \(dqvariable expansion\(dq. This is the replacing of a dollar sign (\fB$\fP) followed by a variable name with the _value_ of that variable.
.sp
In the simplest case, this is just something like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
echo $HOME
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
which will replace \fB$HOME\fP with the home directory of the current user, and pass it to \fI\%echo\fP, which will then print it.
.sp
Some variables like \fB$HOME\fP are already set because fish sets them by default or because fish\(aqs parent process passed them to fish when it started it. You can define your own variables by setting them with \fI\%set\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set my_directory /home/cooluser/mystuff
ls $my_directory
# shows the contents of /home/cooluser/mystuff
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For more on how setting variables works, see \fI\%Shell variables\fP and the following sections.
.sp
Sometimes a variable has no value because it is undefined or empty, and it expands to nothing:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
echo $nonexistentvariable
# Prints no output.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To separate a variable name from text you can encase the variable within double\-quotes or braces:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set WORD cat
echo The plural of $WORD is \(dq$WORD\(dqs
# Prints \(dqThe plural of cat is cats\(dq because $WORD is set to \(dqcat\(dq.
echo The plural of $WORD is {$WORD}s
# ditto
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Without the quotes or braces, fish will try to expand a variable called \fB$WORDs\fP, which may not exist.
.sp
The latter syntax \fB{$WORD}\fP is a special case of \fI\%brace expansion\fP\&.
.sp
If $WORD here is undefined or an empty list, the \(dqs\(dq is not printed. However, it is printed if $WORD is the empty string (like after \fBset WORD \(dq\(dq\fP).
.sp
For more on shell variables, read the \fI\%Shell variables\fP section.
.SS Quoting variables
.sp
Unlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (\fB\(dqthese\(dq\fP), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they\(aqll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a \fI\%path variable\fP \- in that case it will use a colon (\fB:\fP) instead [3]\&.
.sp
Outside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.
.sp
If a variable expands to nothing, it will cancel out any other strings attached to it. See the \fI\%cartesian product\fP section for more information.
.sp
Unlike other shells, fish doesn\(aqt do what is known as \(dqWord Splitting\(dq. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren\(aqt split on spaces or newlines or anything:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> set foo one\enthing
> echo $foo
one
thing
> printf \(aq|%s|\en\(aq $foo
|one
thing|
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
That means quoting isn\(aqt the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with \fI\%test\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set \-l foo one two three
test \-n $foo
# prints an error that it got too many arguments, because it was executed like
test \-n one two three

test \-n \(dq$foo\(dq
# works, because it was executed like
test \-n \(dqone two three\(dq
.ft P
.fi
.UNINDENT
.UNINDENT
.IP [3] 5
Unlike bash or zsh, which will join with the first character of $IFS (which usually is space).
.SS Dereferencing variables
.sp
The \fB$\fP symbol can also be used multiple times, as a kind of \(dqdereference\(dq operator (the \fB*\fP in C or C++), like in the following code:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set foo a b c
set a 10; set b 20; set c 30
for i in (seq (count $$foo))
    echo $$foo[$i]
end

# Output is:
# 10
# 20
# 30
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB$$foo[$i]\fP is \(dqthe value of the variable named by \fB$foo[$i]\fP\&.
.sp
When using this feature together with list brackets, the brackets will be used from the inside out. \fB$$foo[5]\fP will use the fifth element of \fB$foo\fP as a variable name, instead of giving the fifth element of all the variables $foo refers to. That would instead be expressed as \fB$$foo[1..\-1][5]\fP (take all elements of \fB$foo\fP, use them as variable names, then give the fifth element of those).
.SS Command substitution
.sp
A \fBcommand substitution\fP is an expansion that uses the \fIoutput\fP of a command as the arguments to another. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
echo (pwd)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This executes the \fI\%pwd\fP command, takes its output (more specifically what it wrote to the standard output \(dqstdout\(dq stream) and uses it as arguments to \fI\%echo\fP\&. So the inner command (the \fBpwd\fP) is run first and has to complete before the outer command can even be started.
.sp
If the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of \fB$IFS\fP is not used [4], fish splits on newlines.
.sp
A command substitution can also be spelled with a dollar sign like \fBoutercommand $(innercommand)\fP\&. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.
.sp
If the output is piped to \fI\%string split or string split0\fP as the last step, those splits are used as they appear instead of splitting lines.
.sp
The exit status of the last run command substitution is available in the \fI\%status\fP variable if the substitution happens in the context of a \fI\%set\fP command (so \fBif set \-l (something)\fP checks if \fBsomething\fP returned true).
.sp
To use only some lines of the output, refer to \fI\%slices\fP\&.
.sp
Examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Outputs \(aqimage.png\(aq.
echo (basename image.jpg .jpg).png

# Convert all JPEG files in the current directory to the
# PNG format using the \(aqconvert\(aq program.
for i in *.jpg; convert $i (basename $i .jpg).png; end

# Set the \(ga\(gadata\(ga\(ga variable to the contents of \(aqdata.txt\(aq
# without splitting it into a list.
set data \(dq$(cat data.txt)\(dq

# Set \(ga\(ga$data\(ga\(ga to the contents of data, splitting on NUL\-bytes.
set data (cat data | string split0)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Sometimes you want to pass the output of a command to another command that only accepts files. If it\(aqs just one file, you can usually just pass it via a pipe, like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
grep fish myanimallist1 | wc \-l
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
but if you need multiple or the command doesn\(aqt read from standard input, \(dqprocess substitution\(dq is useful. Other shells allow this via \fBfoo <(bar) <(baz)\fP, and fish uses the \fI\%psub\fP command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Compare just the lines containing \(dqfish\(dq in two files:
diff \-u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.
.sp
Fish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution \- the outer command won\(aqt be executed at all) fails and \fB$status\fP is set to 122. This is so command substitutions can\(aqt cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the \fBfish_read_limit\fP variable (\fI0\fP meaning no limit). This limit also affects the \fI\%read\fP command.
.IP [4] 5
One exception: Setting \fB$IFS\fP to empty will disable line splitting. This is deprecated, use \fI\%string split\fP instead.
.SS Brace expansion
.sp
Curly braces can be used to write comma\-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.
.sp
Examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> echo input.{c,h,txt}
input.c input.h input.txt

# Move all files with the suffix \(aq.c\(aq or \(aq.h\(aq to the subdirectory src.
> mv *.{c,h} src/

# Make a copy of \(gafile\(ga at \(gafile.bak\(ga.
> cp file{,.bak}

> set \-l dogs hot cool cute \(dqgood \(dq
> echo {$dogs}dog
hotdog cooldog cutedog good dog
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If there is no \(dq,\(dq or variable expansion between the curly braces, they will not be expanded:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# This {} isn\(aqt special
> echo foo\-{}
foo\-{}
# This passes \(dqHEAD@{2}\(dq to git
> git reset \-\-hard HEAD@{2}
> echo {{a,b}}
{a} {b} # because the inner brace pair is expanded, but the outer isn\(aqt.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If after expansion there is nothing between the braces, the argument will be removed (see \fI\%the cartesian product section\fP):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> echo foo\-{$undefinedvar}
# Output is an empty line, just like a bare \(gaecho\(ga.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If there is nothing between a brace and a comma or two commas, it\(aqs interpreted as an empty element:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> echo {,,/usr}/bin
/bin /bin /usr/bin
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To use a \(dq,\(dq as an element, \fI\%quote\fP or \fI\%escape\fP it.
.SS Combining lists (Cartesian Product)
.sp
When lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the \(dqcartesian product\(dq (like in mathematics), and works basically like \fI\%brace expansion\fP\&.
.sp
Examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Brace expansion is the most familiar:
# All elements in the brace combine with the parts outside of the braces
>_ echo {good,bad}\(dq apples\(dq
good apples bad apples

# The same thing happens with variable expansion.
>_ set \-l a x y z
>_ set \-l b 1 2 3

# $a is {x,y,z}, $b is {1,2,3},
# so this is \(gaecho {x,y,z}{1,2,3}\(ga
>_ echo $a$b
x1 y1 z1 x2 y2 z2 x3 y3 z3

# Same thing if something is between the lists
>_ echo $a\(dq\-\(dq$b
x\-1 y\-1 z\-1 x\-2 y\-2 z\-2 x\-3 y\-3 z\-3

# Or a brace expansion and a variable
>_ echo {x,y,z}$b
x1 y1 z1 x2 y2 z2 x3 y3 z3

# A combined brace\-variable expansion
>_ echo {$b}word
1word 2word 3word

# Special case: If $c has no elements, this expands to nothing
>_ echo {$c}word
# Output is an empty line
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Sometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double\-quote variables \- \fBecho \(dq$c\(dqword\fP\&.
.sp
This also happens after \fI\%command substitution\fP\&. To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double\-quote it.
.sp
E.g.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
>_ set b 1 2 3
>_ echo (echo x)$b
x1 x2 x3
>_ echo (printf \(aq%s\(aq \(aq\(aq)banana
# the printf prints nothing, so this is nothing times \(dqbanana\(dq,
# which is nothing.
>_ echo (printf \(aq%s\en\(aq \(aq\(aq)banana
# the printf prints a newline,
# so the command substitution expands to an empty string,
# so this is \(ga\(aq\(aqbanana\(ga
banana
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This can be quite useful. For example, if you want to go through all the files in all the directories in \fI\%PATH\fP, use
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
for file in $PATH/*
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Because \fI\%PATH\fP is a list, this expands to all the files in all the directories in it. And if there are no directories in \fI\%PATH\fP, the right answer here is to expand to no files.
.SS Slices
.sp
Sometimes it\(aqs necessary to access only some of the elements of a \fI\%list\fP (all fish variables are lists), or some of the lines a \fI\%command substitution\fP outputs. Both are possible in fish by writing a set of indices in brackets, like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Make $var a list of four elements
set var one two three four
# Print the second:
echo $var[2]
# prints \(dqtwo\(dq
# or print the first three:
echo $var[1..3]
# prints \(dqone two three\(dq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In index brackets, fish understands ranges written like \fBa..b\fP (\(aqa\(aq and \(aqb\(aq being indices). They are expanded into a sequence of indices from a to b (so \fBa a+1 a+2 ... b\fP), going up if b is larger and going down if a is larger. Negative indices can also be used \- they are taken from the end of the list, so \fB\-1\fP is the last element, and \fB\-2\fP the one before it. If an index doesn\(aqt exist the range is clamped to the next possible index.
.sp
If a list has 5 elements the indices go from 1 to 5, so a range of \fB2..16\fP will only go from element 2 to element 5.
.sp
If the end is negative the range always goes up, so \fB2..\-2\fP will go from element 2 to 4, and \fB2..\-16\fP won\(aqt go anywhere because there is no way to go from the second element to one that doesn\(aqt exist, while going up.
If the start is negative the range always goes down, so \fB\-2..1\fP will go from element 4 to 1, and \fB\-16..2\fP won\(aqt go anywhere because there is no way to go from an element that doesn\(aqt exist to the second element, while going down.
.sp
A missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to \-1 is allowed for the last index in the sequence.
.sp
Multiple ranges are also possible, separated with a space.
.sp
Some examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
echo (seq 10)[1 2 3]
# Prints: 1 2 3

# Limit the command substitution output
echo (seq 10)[2..5]
# Uses elements from 2 to 5
# Output is: 2 3 4 5

echo (seq 10)[7..]
# Prints: 7 8 9 10

# Use overlapping ranges:
echo (seq 10)[2..5 1..3]
# Takes elements from 2 to 5 and then elements from 1 to 3
# Output is: 2 3 4 5 1 2 3

# Reverse output
echo (seq 10)[\-1..1]
# Uses elements from the last output line to
# the first one in reverse direction
# Output is: 10 9 8 7 6 5 4 3 2 1

# The command substitution has only one line,
# so these will result in empty output:
echo (echo one)[2..\-1]
echo (echo one)[\-3..1]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The same works when setting or expanding variables:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Reverse path variable
set PATH $PATH[\-1..1]
# or
set PATH[\-1..1] $PATH

# Use only n last items of the PATH
set n \-3
echo $PATH[$n..\-1]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Variables can be used as indices for expansion of variables, like so:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set index 2
set letters a b c d
echo $letters[$index] # returns \(aqb\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
However using variables as indices for command substitution is currently not supported, so:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
echo (seq 5)[$index] # This won\(aqt work

set sequence (seq 5) # It needs to be written on two lines like this.
echo $sequence[$index] # returns \(aq2\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When using indirect variable expansion with multiple \fB$\fP (\fB$$name\fP), you have to give all indices up to the variable you want to slice:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> set \-l list 1 2 3 4 5
> set \-l name list
> echo $$name[1]
1 2 3 4 5
> echo $$name[1..\-1][1..3] # or $$name[1][1..3], since $name only has one element.
1 2 3
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Home directory expansion
.sp
The \fB~\fP (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone \fB~\fP, or a \fB~\fP followed by a slash, is expanded into the home directory of the process owner:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
ls ~/Music # lists my music directory

echo ~root # prints root\(aqs home directory, probably \(dq/root\(dq
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Combining different expansions
.sp
All of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.
.sp
When combining multiple parameter expansions, expansions are performed in the following order:
.INDENT 0.0
.IP \(bu 2
Command substitutions
.IP \(bu 2
Variable expansions
.IP \(bu 2
Bracket expansion
.IP \(bu 2
Wildcard expansion
.UNINDENT
.sp
Expansions are performed from right to left, nested bracket expansions are performed from the inside and out.
.sp
Example:
.sp
If the current directory contains the files \(aqfoo\(aq and \(aqbar\(aq, the command \fBecho a(ls){1,2,3}\fP will output \fBabar1 abar2 abar3 afoo1 afoo2 afoo3\fP\&.
.SH SHELL VARIABLES
.sp
Variables are a way to save data and pass it around. They can be used just by the shell, or they can be \(dq\fI\%exported\fP\(dq, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an \(dqenvironment variable\(dq.
.sp
To set a variable value, use the \fI\%set\fP command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.
.sp
Example:
.sp
To set the variable \fBsmurf_color\fP to the value \fBblue\fP, use the command \fBset smurf_color blue\fP\&.
.sp
After a variable has been set, you can use the value of a variable in the shell through \fI\%variable expansion\fP\&.
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set smurf_color blue
echo Smurfs are usually $smurf_color
set pants_color red
echo Papa smurf, who is $smurf_color, wears $pants_color pants
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
So you set a variable with \fBset\fP, and use it with a \fB$\fP and the name.
.SS Variable Scope
.sp
There are four kinds of variables in fish: universal, global, function and local variables.
.INDENT 0.0
.IP \(bu 2
Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.
.IP \(bu 2
Global variables are specific to the current fish session. They can be erased by explicitly requesting \fBset \-e\fP\&.
.IP \(bu 2
Function variables are specific to the currently executing function. They are erased (\(dqgo out of scope\(dq) when the current function ends. Outside of a function, they don\(aqt go out of scope.
.IP \(bu 2
Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands \fBfor\fP, \fBwhile\fP , \fBif\fP, \fBfunction\fP, \fBbegin\fP or \fBswitch\fP, and ends with the command \fBend\fP\&. Outside of a block, this is the same as the function scope.
.UNINDENT
.sp
Variables can be explicitly set to be universal with the \fB\-U\fP or \fB\-\-universal\fP switch, global with \fB\-g\fP or \fB\-\-global\fP, function\-scoped with \fB\-f\fP or \fB\-\-function\fP and local to the current block with \fB\-l\fP or \fB\-\-local\fP\&.  The scoping rules when creating or updating a variable are:
.INDENT 0.0
.IP \(bu 2
When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.
.IP \(bu 2
When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.
.IP \(bu 2
When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.
.UNINDENT
.sp
There can be many variables with the same name, but different scopes. When you \fI\%use a variable\fP, the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.
.sp
Example:
.sp
There are a few possible uses for different scopes.
.sp
Typically inside functions you should use local scope:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function something
    set \-l file /path/to/my/file
    if not test \-e \(dq$file\(dq
        set file /path/to/my/otherfile
    end
end

# or

function something
    if test \-e /path/to/my/file
        set \-f file /path/to/my/file
    else
        set \-f file /path/to/my/otherfile
    end
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Don\(aqt shorten the working directory in the prompt
set \-g fish_prompt_pwd_dir_length 0

# Set my preferred cursor style:
function setcursors
   set \-g fish_cursor_default block
   set \-g fish_cursor_insert line
   set \-g fish_cursor_visual underscore
end

# Set my language
set \-gx LANG de_DE.UTF\-8
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you want to set some personal customization, universal variables are nice:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Typically you\(aqd run this interactively, fish takes care of keeping it.
set \-U fish_color_autosuggestion 555
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here is an example of local vs function\-scoped variables:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function test\-scopes
    begin
        # This is a nice local scope where all variables will die
        set \-l pirate \(aqThere be treasure in them thar hills\(aq
        set \-f captain Space, the final frontier
        # If no variable of that name was defined, it is function\-local.
        set gnu \(dqIn the beginning there was nothing, which exploded\(dq
    end

    echo $pirate
    # This will not output anything, since the pirate was local
    echo $captain
    # This will output the good Captain\(aqs speech since $captain had function\-scope.
    echo $gnu
    # Will output Sir Terry\(aqs wisdom.
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When a function calls another, local variables aren\(aqt visible:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function shiver
    set phrase \(aqShiver me timbers\(aq
end

function avast
    set \-\-local phrase \(aqAvast, mateys\(aq
    # Calling the shiver function here can not
    # change any variables in the local scope
    # so phrase remains as we set it here.
    shiver
    echo $phrase
end
avast

# Outputs \(dqAvast, mateys\(dq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When in doubt, use function\-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.
.SS Overriding variables for a single command
.sp
If you want to override a variable for a single command, you can use \(dqvar=val\(dq statements before the command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Call git status on another directory
# (can also be done via \(gagit \-C somerepo status\(ga)
GIT_DIR=somerepo git status
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Unlike other shells, fish will first set the variable and then perform other expansions on the line, so:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set foo banana
foo=gagaga echo $foo # prints gagaga, while in other shells it might print \(dqbanana\(dq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Multiple elements can be given in a \fI\%brace expansion\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Call bash with a reasonable default path.
PATH={/usr,}/{s,}bin bash
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or with a \fI\%glob\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Run vlc on all mp3 files in the current directory
# If no file exists it will still be run with no arguments
mp3s=*.mp3 vlc $mp3s
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Unlike other shells, this does \fInot\fP inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.
.sp
This syntax is supported since fish 3.1.
.SS Universal Variables
.sp
Universal variables are variables that are shared between all the user\(aqs fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.
.sp
To see universal variables in action, start two fish sessions side by side, and issue the following command in one of them \fBset fish_color_cwd blue\fP\&. Since \fBfish_color_cwd\fP is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.
.sp
\fI\%Universal variables\fP are stored in the file \fB\&.config/fish/fish_variables\fP\&. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.
.sp
Do not append to universal variables in \fI\%config.fish\fP, because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.
.SS Exporting variables
.sp
Variables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like \fBPAGER\fP or \fBGOPATH\fP, but also for variables that contain general system settings like \fBPATH\fP or \fBLANGUAGE\fP\&. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called \(dqenvironment variables\(dq.
.sp
This also applies to fish \- when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like \fI\%PATH\fP and \fI\%locale variables\fP\&.
.sp
Variables can be explicitly set to be exported with the \fB\-x\fP or \fB\-\-export\fP switch, or not exported with the \fB\-u\fP or \fB\-\-unexport\fP switch.  The exporting rules when setting a variable are similar to the scoping rules for variables \- when an option is passed it is respected, otherwise the variable\(aqs existing state is used. If no option is passed and the variable didn\(aqt exist yet it is not exported.
.sp
As a naming convention, exported variables are in uppercase and unexported variables are in lowercase.
.sp
For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set \-gx ANDROID_HOME ~/.android # /opt/android\-sdk
set \-gx CDPATH . ~ (test \-e ~/Videos; and echo ~/Videos)
set \-gx EDITOR emacs \-nw
set \-gx GOPATH ~/dev/go
set \-gx GTK2_RC_FILES \(dq$XDG_CONFIG_HOME/gtk\-2.0/gtkrc\(dq
set \-gx LESSHISTFILE \(dq\-\(dq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note: Exporting is not a \fI\%scope\fP, but an additional state. It typically makes sense to make exported variables global as well, but local\-exported variables can be useful if you need something more specific than \fI\%Overrides\fP\&. They are \fIcopied\fP to functions so the function can\(aqt alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.
.SS Lists
.sp
Fish can store a list (or an \(dqarray\(dq if you wish) of multiple strings inside of a variable:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> set mylist first second third
> printf \(aq%s\en\(aq $mylist # prints each element on its own line
first
second
third
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To access one element of a list, use the index of the element inside of square brackets, like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
echo $PATH[3]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
List indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like \fBseq\fP work better with it (\fBseq 5\fP prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).
.sp
If you don\(aqt use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with \fBfor\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
for i in $PATH
    echo $i is in the path
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This goes over every directory in \fI\%PATH\fP separately and prints a line saying it is in the path.
.sp
To create a variable \fBsmurf\fP, containing the items \fBblue\fP and \fBsmall\fP, simply write:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set smurf blue small
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It is also possible to set or erase individual elements of a list:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Set smurf to be a list with the elements \(aqblue\(aq and \(aqsmall\(aq
set smurf blue small

# Change the second element of smurf to \(aqevil\(aq
set smurf[2] evil

# Erase the first element
set \-e smurf[1]

# Output \(aqevil\(aq
echo $smurf
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you specify a negative index when expanding or assigning to a list variable, the index will be taken from the \fIend\fP of the list. For example, the index \-1 is the last element of the list:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> set fruit apple orange banana
> echo $fruit[\-1]
banana

> echo $fruit[\-2..\-1]
orange
banana

> echo $fruit[\-1..1] # reverses the list
banana
orange
apple
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
As you see, you can use a range of indices, see \fI\%slices\fP for details.
.sp
All lists are one\-dimensional and can\(aqt contain other lists, although it is possible to fake nested lists using dereferencing \- see \fI\%variable expansion\fP\&.
.sp
When a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a \fI\%path variable\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> set \-x smurf blue small
> set \-x smurf_PATH forest mushroom
> env | grep smurf
smurf=blue small
smurf_PATH=forest:mushroom
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Fish automatically creates lists from all environment variables whose name ends in \fBPATH\fP (like \fI\%PATH\fP, \fI\%CDPATH\fP or \fBMANPATH\fP), by splitting them on colons. Other variables are not automatically split.
.sp
Lists can be inspected with the \fI\%count\fP or the \fI\%contains\fP commands:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> count $smurf
2

> contains blue $smurf
# blue was found, so it exits with status 0
# (without printing anything)

> echo $status
0

> contains \-i blue $smurf
1
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
A nice thing about lists is that they are passed to commands one element as one argument, so once you\(aqve set your list, you can just pass it:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set \-l grep_args \-r \(dqmy string\(dq
grep $grep_args . # will run the same as \(gagrep \-r \(dqmy string\(dq\(ga .
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Unlike other shells, fish does not do \(dqword splitting\(dq \- elements in a list stay as they are, even if they contain spaces or tabs.
.SS Argument Handling
.sp
An important list is \fB$argv\fP, which contains the arguments to a function or script. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function myfunction
    echo $argv[1]
    echo $argv[3]
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This function takes whatever arguments it gets and prints the first and third:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> myfunction first second third
first
third

> myfunction apple cucumber banana
apple
banana
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
That covers the positional arguments, but commandline tools often get various options and flags, and $argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (\fB\-h\fP, also grouped like in \fBls \-lah\fP), long options (\fB\-\-help\fP) and allows those options to take arguments (\fB\-\-color=auto\fP or \fB\-\-position anywhere\fP or \fBcomplete \-C\(dqgit \(dq\fP) as well as a \fB\-\-\fP separator to signal the end of options. Handling all of these manually is tricky and error\-prone.
.sp
A more robust approach to option handling is \fI\%argparse\fP, which checks the defined options and puts them into various variables, leaving only the positional arguments in $argv. Here\(aqs a simple example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function mybetterfunction
    # We tell argparse about \-h/\-\-help and \-s/\-\-second \- these are short and long forms of the same option.
    # The \(dq\-\-\(dq here is mandatory, it tells it from where to read the arguments.
    argparse h/help s/second \-\- $argv
    # exit if argparse failed because it found an option it didn\(aqt recognize \- it will print an error
    or return

    # If \-h or \-\-help is given, we print a little help text and return
    if set \-ql _flag_help
        echo \(dqmybetterfunction [\-h|\-\-help] [\-s|\-\-second] [ARGUMENT ...]\(dq
        return 0
    end

    # If \-s or \-\-second is given, we print the second argument,
    # not the first and third.
    # (this is also available as _flag_s because of the short version)
    if set \-ql _flag_second
        echo $argv[2]
    else
        echo $argv[1]
        echo $argv[3]
    end
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The options will be \fIremoved\fP from $argv, so $argv[2] is the second \fIpositional\fP argument now:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> mybetterfunction first \-s second third
second
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For more information on argparse, like how to handle option arguments, see \fI\%the argparse documentation\fP\&.
.SS PATH variables
.sp
Path variables are a special kind of variable used to support colon\-delimited path lists including \fI\%PATH\fP, \fI\%CDPATH\fP, \fBMANPATH\fP, \fBPYTHONPATH\fP, etc. All variables that end in \(dqPATH\(dq (case\-sensitive) become PATH variables by default.
.sp
PATH variables act as normal lists, except they are implicitly joined and split on colons.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set MYPATH 1 2 3
echo \(dq$MYPATH\(dq
# 1:2:3
set MYPATH \(dq$MYPATH:4:5\(dq
echo $MYPATH
# 1 2 3 4 5
echo \(dq$MYPATH\(dq
# 1:2:3:4:5
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Path variables will also be exported in the colon form, so \fBset \-x MYPATH 1 2 3\fP will have external commands see it as \fB1:2:3\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> set \-gx MYPATH /bin /usr/bin /sbin
> env | grep MYPATH
MYPATH=/bin:/usr/bin:/sbin
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is for compatibility with other tools. Unix doesn\(aqt have variables with multiple elements, the closest thing it has are colon\-lists like \fI\%PATH\fP\&. For obvious reasons this means no element can contain a \fB:\fP\&.
.sp
Variables can be marked or unmarked as PATH variables via the \fB\-\-path\fP and \fB\-\-unpath\fP options to \fBset\fP\&.
.SS Special variables
.sp
You can change the settings of fish by changing the values of certain variables.
.INDENT 0.0
.TP
.B PATH
A list of directories in which to search for commands. This is a common unix variable also used by other tools.
.UNINDENT
.INDENT 0.0
.TP
.B CDPATH
A list of directories in which the \fI\%cd\fP builtin looks for a new directory.
.UNINDENT
.INDENT 0.0
.TP
.B Locale Variables
The locale variables \fI\%LANG\fP, \fI\%LC_ALL\fP, \fI\%LC_COLLATE\fP, \fI\%LC_CTYPE\fP, \fI\%LC_MESSAGES\fP, \fI\%LC_MONETARY\fP, \fI\%LC_NUMERIC\fP, and \fI\%LANG\fP set the language option for the shell and subprograms. See the section \fI\%Locale variables\fP for more information.
.UNINDENT
.INDENT 0.0
.TP
.B Color variables
A number of variable starting with the prefixes \fBfish_color\fP and \fBfish_pager_color\fP\&. See \fI\%Variables for changing highlighting colors\fP for more information.
.UNINDENT
.INDENT 0.0
.TP
.B fish_term24bit
If this is set to 1, fish will assume the terminal understands 24\-bit RGB color sequences, and won\(aqt translate them to the 256 or 16 color palette.
This is often detected automatically.
.UNINDENT
.INDENT 0.0
.TP
.B fish_term256
If this is set to 1, fish will assume the terminal understands 256 colors, and won\(aqt translate matching colors down to the 16 color palette.
This is usually autodetected.
.UNINDENT
.INDENT 0.0
.TP
.B fish_ambiguous_width
controls the computed width of ambiguous\-width characters. This should be set to 1 if your terminal renders these characters as single\-width (typical), or 2 if double\-width.
.UNINDENT
.INDENT 0.0
.TP
.B fish_emoji_width
controls whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other \(dqspecial\(dq characters). It should usually be auto\-detected.
.UNINDENT
.INDENT 0.0
.TP
.B fish_autosuggestion_enabled
controls if \fI\%Autosuggestions\fP are enabled. Set it to 0 to disable, anything else to enable. By default they are on.
.UNINDENT
.INDENT 0.0
.TP
.B fish_handle_reflow
determines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.
.UNINDENT
.INDENT 0.0
.TP
.B fish_key_bindings
the name of the function that sets up the keyboard shortcuts for the \fI\%command\-line editor\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B fish_escape_delay_ms
sets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see \fI\%the chapter in the bind documentation\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B fish_complete_path
determines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.
.UNINDENT
.INDENT 0.0
.TP
.B fish_cursor_selection_mode
controls whether the selection is inclusive or exclusive of the character under the cursor (see \fI\%Copy and Paste\fP).
.UNINDENT
.INDENT 0.0
.TP
.B fish_function_path
determines where fish looks for functions. When fish \fI\%autoloads\fP a function, it will look for files in these directories.
.UNINDENT
.INDENT 0.0
.TP
.B fish_greeting
the greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see \fI\%funced\fP)
.UNINDENT
.INDENT 0.0
.TP
.B fish_history
the current history session name. If set, all subsequent commands within an
interactive fish session will be logged to a separate file identified by the value of the
variable. If unset, the default session name \(dqfish\(dq is used. If set to an
empty string, history is not saved to disk (but is still available within the interactive
session).
.UNINDENT
.INDENT 0.0
.TP
.B fish_trace
if set and not empty, will cause fish to print commands before they execute, similar to \fBset \-x\fP
in bash. The trace is printed to the path given by the \fI\-\-debug\-output\fP option to fish or the \fI\%FISH_DEBUG_OUTPUT\fP variable. It goes to stderr by default.
.UNINDENT
.INDENT 0.0
.TP
.B FISH_DEBUG
Controls which debug categories \fBfish\fP enables for output, analogous to the \fB\-\-debug\fP option.
.UNINDENT
.INDENT 0.0
.TP
.B FISH_DEBUG_OUTPUT
Specifies a file to direct debug output to.
.UNINDENT
.INDENT 0.0
.TP
.B fish_user_paths
a list of directories that are prepended to \fI\%PATH\fP\&. This can be a universal variable.
.UNINDENT
.INDENT 0.0
.TP
.B umask
the current file creation mask. The preferred way to change the umask variable is through the \fI\%umask\fP function. An attempt to set umask to an invalid value will always fail.
.UNINDENT
.INDENT 0.0
.TP
.B BROWSER
your preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.
.UNINDENT
.sp
Fish also provides additional information through the values of certain environment variables. Most of these variables are read\-only and their value can\(aqt be changed with \fBset\fP\&.
.INDENT 0.0
.TP
.B _
the name of the currently running command (though this is deprecated, and the use of \fBstatus current\-command\fP is preferred).
.UNINDENT
.INDENT 0.0
.TP
.B argv
a list of arguments to the shell or function. \fBargv\fP is only defined when inside a function call, or if fish was invoked with a list of arguments, like \fBfish myscript.fish foo bar\fP\&. This variable can be changed.
.UNINDENT
.INDENT 0.0
.TP
.B CMD_DURATION
the runtime of the last command in milliseconds.
.UNINDENT
.INDENT 0.0
.TP
.B COLUMNS and LINES
the current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.
.UNINDENT
.INDENT 0.0
.TP
.B fish_kill_signal
the signal that terminated the last foreground job, or 0 if the job exited normally.
.UNINDENT
.INDENT 0.0
.TP
.B fish_killring
a list of entries in fish\(aqs \fI\%kill ring\fP of cut text.
.UNINDENT
.INDENT 0.0
.TP
.B fish_read_limit
how many bytes fish will process with \fI\%read\fP or in a \fI\%command substitution\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B fish_pid
the process ID (PID) of the shell.
.UNINDENT
.INDENT 0.0
.TP
.B history
a list containing the last commands that were entered.
.UNINDENT
.INDENT 0.0
.TP
.B HOME
the user\(aqs home directory. This variable can be changed.
.UNINDENT
.INDENT 0.0
.TP
.B hostname
the machine\(aqs hostname.
.UNINDENT
.INDENT 0.0
.TP
.B IFS
the internal field separator that is used for word splitting with the \fI\%read\fP builtin. Setting this to the empty string will also disable line splitting in \fI\%command substitution\fP\&. This variable can be changed.
.UNINDENT
.INDENT 0.0
.TP
.B last_pid
the process ID (PID) of the last background process.
.UNINDENT
.INDENT 0.0
.TP
.B PWD
the current working directory.
.UNINDENT
.INDENT 0.0
.TP
.B pipestatus
a list of exit statuses of all processes that made up the last executed pipe. See \fI\%exit status\fP\&.
.UNINDENT
.INDENT 0.0
.TP
.B SHLVL
the level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.
.UNINDENT
.INDENT 0.0
.TP
.B status
the \fI\%exit status\fP of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.
.UNINDENT
.INDENT 0.0
.TP
.B status_generation
the \(dqgeneration\(dq count of \fB$status\fP\&. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).
.UNINDENT
.INDENT 0.0
.TP
.B TERM
the type of the current terminal. When fish tries to determine how the terminal works \- how many colors it supports, what sequences it sends for keys and other things \- it looks at this variable and the corresponding information in the terminfo database (see \fBman terminfo\fP).
.sp
Note: Typically this should not be changed as the terminal sets it to the correct value.
.UNINDENT
.INDENT 0.0
.TP
.B USER
the current username. This variable can be changed.
.UNINDENT
.INDENT 0.0
.TP
.B EUID
the current effective user id, set by fish at startup. This variable can be changed.
.UNINDENT
.INDENT 0.0
.TP
.B version
the version of the currently running fish (also available as \fBFISH_VERSION\fP for backward compatibility).
.UNINDENT
.sp
As a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (\fBCMD_DURATION\fP is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.
.sp
Fish also uses some variables internally, their name usually starting with \fB__fish\fP\&. These are internal and should not typically be modified directly.
.SS The status variable
.sp
Whenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non\-zero exit status means there was some form of problem.
.sp
Fish stores the exit status of the last process in the last job to exit in the \fBstatus\fP variable.
.sp
If fish encounters a problem while executing a command, the status variable may also be set to a specific value:
.INDENT 0.0
.IP \(bu 2
0 is generally the exit status of commands if they successfully performed the requested operation.
.IP \(bu 2
1 is generally the exit status of commands if they failed to perform the requested operation.
.IP \(bu 2
121 is generally the exit status of commands if they were supplied with invalid arguments.
.IP \(bu 2
123 means that the command was not executed because the command name contained invalid characters.
.IP \(bu 2
124 means that the command was not executed because none of the wildcards in the command produced any matches.
.IP \(bu 2
125 means that while an executable with the specified name was located, the operating system could not actually execute the command.
.IP \(bu 2
126 means that while a file with the specified name was located, it was not executable.
.IP \(bu 2
127 means that no function, builtin or command with the given name could be located.
.UNINDENT
.sp
If a process exits through a signal, the exit status will be 128 plus the number of the signal.
.sp
The status can be negated with \fI\%not\fP (or \fB!\fP), which is useful in a \fI\%condition\fP\&. This turns a status of 0 into 1 and any non\-zero status into 0.
.sp
There is also \fB$pipestatus\fP, which is a list of all \fBstatus\fP values of processes in a pipe. One difference is that \fI\%not\fP applies to \fB$status\fP, but not \fB$pipestatus\fP, because it loses information.
.sp
For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
not cat file | grep \-q fish
echo status is: $status pipestatus is $pipestatus
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here \fB$status\fP reflects the status of \fBgrep\fP, which returns 0 if it found something, negated with \fBnot\fP (so 1 if it found something, 0 otherwise). \fB$pipestatus\fP reflects the status of \fBcat\fP (which returns non\-zero for example when it couldn\(aqt find the file) and \fBgrep\fP, without the negation.
.sp
So if both \fBcat\fP and \fBgrep\fP succeeded, \fB$status\fP would be 1 because of the \fBnot\fP, and \fB$pipestatus\fP would be 0 and 0.
.sp
It\(aqs possible for the first command to fail while the second succeeds. One common example is when the second program quits early.
.sp
For example, if you have a pipeline like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cat file1 file2 | head \-n 50
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This will tell \fBcat\fP to print two files, \(dqfile1\(dq and \(dqfile2\(dq, one after the other, and the \fBhead\fP will then only print the first 50 lines. In this case you might often see this constellation:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> cat file1 file2 | head \-n 50
# 50 lines of output
> echo $pipestatus
141 0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here, the \(dq141\(dq signifies that \fBcat\fP was killed by signal number 13 (128 + 13 == 141) \- a \fBSIGPIPE\fP\&. You can also use \fI\%fish_kill_signal\fP to see the signal number. This happens because it was still working, and then \fBhead\fP closed the pipe, so \fBcat\fP received a signal that it didn\(aqt ignore and so it died.
.sp
Whether \fBcat\fP here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of \(dq0 0\(dq, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a \(dqpipefail\(dq feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.
.SS Locale Variables
.sp
The \(dqlocale\(dq of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:
.INDENT 0.0
.TP
.B LANG
This is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like \fBC\fP or \fBPOSIX\fP\&.
.sp
The value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.
.sp
An example value might be \fBen_US.UTF\-8\fP for the american version of english and the UTF\-8 encoding, or \fBde_AT.UTF\-8\fP for the austrian version of german and the UTF\-8 encoding.
Your operating system might have a \fBlocale\fP command that you can call as \fBlocale \-a\fP to see a list of defined locales.
.sp
A UTF\-8 encoding is recommended.
.UNINDENT
.INDENT 0.0
.TP
.B LC_ALL
Overrides the \fI\%LANG\fP environment variable and the values of the other \fBLC_*\fP variables. If this is set, none of the other variables are used for anything.
.sp
Usually the other variables should be used instead. Use LC_ALL only when you need to override something.
.UNINDENT
.INDENT 0.0
.TP
.B LC_COLLATE
This determines the rules about equivalence of cases and alphabetical ordering: collation.
.UNINDENT
.INDENT 0.0
.TP
.B LC_CTYPE
This determines classification rules, like if the type of character is an alpha, digit, and so on.
Most importantly, it defines the text \fIencoding\fP \- which numbers map to which characters. On modern systems, this should typically be something ending in \(dqUTF\-8\(dq.
.UNINDENT
.INDENT 0.0
.TP
.B LC_MESSAGES
\fBLC_MESSAGES\fP determines the language in which messages are diisplayed.
.UNINDENT
.INDENT 0.0
.TP
.B LC_MONETARY
Determines currency, how it is formated, and the symbols used.
.UNINDENT
.INDENT 0.0
.TP
.B LC_NUMERIC
Sets the locale for formatting numbers.
.UNINDENT
.INDENT 0.0
.TP
.B LC_TIME
Sets the locale for formatting dates and times.
.UNINDENT
.SH BUILTIN COMMANDS
.sp
Fish includes a number of commands in the shell directly. We call these \(dqbuiltins\(dq. These include:
.INDENT 0.0
.IP \(bu 2
Builtins that manipulate the shell state \- \fI\%cd\fP changes directory, \fI\%set\fP sets variables
.IP \(bu 2
Builtins for dealing with data, like \fI\%string\fP for strings and \fI\%math\fP for numbers, \fI\%count\fP for counting lines or arguments, \fI\%path\fP for dealing with path
.IP \(bu 2
\fI\%status\fP for asking about the shell\(aqs status
.IP \(bu 2
\fI\%printf\fP and \fI\%echo\fP for creating output
.IP \(bu 2
\fI\%test\fP for checking conditions
.IP \(bu 2
\fI\%argparse\fP for parsing function arguments
.IP \(bu 2
\fI\%source\fP to read a script in the current shell (so changes to variables stay) and \fI\%eval\fP to execute a string as script
.IP \(bu 2
\fI\%random\fP to get random numbers or pick a random element from a list
.IP \(bu 2
\fI\%read\fP for reading from a pipe or the terminal
.UNINDENT
.sp
For a list of all builtins, use \fBbuiltin \-n\fP\&.
.sp
For a list of all builtins, functions and commands shipped with fish, see the \fI\%list of commands\fP\&. The documentation is also available by using the \fB\-\-help\fP switch.
.SH COMMAND LOOKUP
.sp
When fish is told to run something, it goes through multiple steps to find it.
.sp
If it contains a \fB/\fP, fish tries to execute the given file, from the current directory on.
.sp
If it doesn\(aqt contain a \fB/\fP, it could be a function, builtin, or external command, and so fish goes through the full lookup.
.sp
In order:
.INDENT 0.0
.IP 1. 3
It tries to resolve it as a \fI\%function\fP\&.
.INDENT 3.0
.IP \(bu 2
If the function is already known, it uses that
.IP \(bu 2
If there is a file of the name with a \(dq.fish\(dq suffix in \fI\%fish_function_path\fP, it \fI\%loads that\fP\&. (If there is more than one file only the first is used)
.IP \(bu 2
If the function is now defined it uses that
.UNINDENT
.IP 2. 3
It tries to resolve it as a \fI\%builtin\fP\&.
.IP 3. 3
It tries to find an executable file in \fI\%PATH\fP\&.
.INDENT 3.0
.IP \(bu 2
If it finds a file, it tells the kernel to run it.
.IP \(bu 2
If the kernel knows how to run the file (e.g. via a \fB#!\fP line \- \fB#!/bin/sh\fP or \fB#!/usr/bin/python\fP), it does it.
.IP \(bu 2
If the kernel reports that it couldn\(aqt run it because of a missing interpreter, and the file passes a rudimentary check, fish tells \fB/bin/sh\fP to run it.
.UNINDENT
.UNINDENT
.sp
If none of these work, fish runs the function \fI\%fish_command_not_found\fP and sets \fI\%status\fP to 127.
.sp
You can use \fI\%type\fP to see how fish resolved something:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> type \-\-short \-\-all echo
echo is a builtin
echo is /usr/bin/echo
.ft P
.fi
.UNINDENT
.UNINDENT
.SH QUERYING FOR USER INPUT
.sp
Sometimes, you want to ask the user for input, for instance to confirm something. This can be done with the \fI\%read\fP builtin.
.sp
Let\(aqs make up an example. This function will \fI\%glob\fP the files in all the directories it gets as \fI\%arguments\fP, and \fI\%if\fP there are \fI\%more than five\fP it will ask the user if it is supposed to show them, but only if it is connected to a terminal:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function show_files
    # This will glob on all arguments. Any non\-directories will be ignored.
    set \-l files $argv/*

    # If there are more than 5 files
    if test (count $files) \-gt 5
        # and both stdin (for reading input) and stdout (for writing the prompt)
        # are terminals
        and isatty stdin
        and isatty stdout
        # Keep asking until we get a valid response
        while read \-\-nchars 1 \-l response \-\-prompt\-str=\(dqAre you sure? (y/n)\(dq
              or return 1 # if the read was aborted with ctrl\-c/ctrl\-d
            switch $response
                case y Y
                    echo Okay
                    # We break out of the while and go on with the function
                    break
                case n N
                    # We return from the function without printing
                    echo Not showing
                    return 1
                case \(aq*\(aq
                    # We go through the while loop and ask again
                    echo Not valid input
                    continue
            end
        end
    end

    # And now we print the files
    printf \(aq%s\en\(aq $files
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you run this as \fBshow_files /\fP, it will most likely ask you until you press Y/y or N/n. If you run this as \fBshow_files / | cat\fP, it will print the files without asking. If you run this as \fBshow_files .\fP, it might just print something without asking because there are fewer than five files.
.SH SHELL VARIABLE AND FUNCTION NAMES
.sp
The names given to variables and functions (so\-called \(dqidentifiers\(dq) have to follow certain rules:
.INDENT 0.0
.IP \(bu 2
A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.
.IP \(bu 2
A function name cannot be empty. It may not begin with a hyphen (\(dq\-\(dq) and may not contain a slash (\(dq/\(dq). All other characters, including a space, are valid. A function name also can\(aqt be the same as a reserved keyword or essential builtin like \fBif\fP or \fBset\fP\&.
.IP \(bu 2
A bind mode name (e.g., \fBbind \-m abc ...\fP) must be a valid variable name.
.UNINDENT
.sp
Other things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a \(dq/\(dq (because that is the path separator) or NULL byte (because that is how UNIX ends strings).
.SH CONFIGURATION FILES
.sp
When fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.
.sp
The main file is \fB~/.config/fish/config.fish\fP (or more precisely \fB$XDG_CONFIG_HOME/fish/config.fish\fP).
.sp
Configuration files are run in the following order:
.INDENT 0.0
.IP \(bu 2
Configuration snippets (named \fB*.fish\fP) in the directories:
.INDENT 2.0
.IP \(bu 2
\fB$__fish_config_dir/conf.d\fP (by default, \fB~/.config/fish/conf.d/\fP)
.IP \(bu 2
\fB$__fish_sysconf_dir/conf.d\fP (by default, \fB/etc/fish/conf.d/\fP)
.IP \(bu 2
Directories for others to ship configuration snippets for their software. Fish searches the directories under \fB$__fish_user_data_dir\fP (usually \fB~/.local/share/fish\fP, controlled by the \fBXDG_DATA_HOME\fP environment variable) and in the \fBXDG_DATA_DIRS\fP environment variable for a \fBfish/vendor_conf.d\fP directory; if not defined, the default value of \fBXDG_DATA_DIRS\fP is \fB/usr/share/fish/vendor_conf.d\fP and \fB/usr/local/share/fish/vendor_conf.d\fP, unless your distribution customized this.
.UNINDENT
.sp
If there are multiple files with the same name in these directories, only the first will be executed.
They are executed in order of their filename, sorted (like globs) in a natural order (i.e. \(dq01\(dq sorts before \(dq2\(dq).
.IP \(bu 2
System\-wide configuration files, where administrators can include initialization for all users on the system \- similar to \fB/etc/profile\fP for POSIX\-style shells \- in \fB$__fish_sysconf_dir\fP (usually \fB/etc/fish/config.fish\fP).
.IP \(bu 2
User configuration, usually in \fB~/.config/fish/config.fish\fP (controlled by the \fBXDG_CONFIG_HOME\fP environment variable, and accessible as \fB$__fish_config_dir\fP).
.UNINDENT
.sp
\fB~/.config/fish/config.fish\fP is sourced \fIafter\fP the snippets. This is so you can copy snippets and override some of their behavior.
.sp
These files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command \fBstatus \-\-is\-interactive\fP to determine if the shell is interactive. If you want to run a command only when using a login shell, use \fBstatus \-\-is\-login\fP instead. This will speed up the starting of non\-interactive or non\-login shells.
.sp
If you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side\-effects or slow the startup of the shell. Additionally, users of other shells won\(aqt benefit from the fish\-specific configuration. However, if they are required, you can install them to the \(dqvendor\(dq configuration directory. As this path may vary from system to system, \fBpkg\-config\fP should be used to discover it: \fBpkg\-config \-\-variable confdir fish\fP\&.
.SH FUTURE FEATURE FLAGS
.sp
Feature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt\-in, in a few releases they become opt\-out, and eventually the old behavior is removed.
.sp
You can see the current list of features via \fBstatus features\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> status features
stderr\-nocaret          on  3.0 ^ no longer redirects stderr
qmark\-noglob            off 3.0 ? no longer globs
regex\-easyesc           on  3.1 string replace \-r needs fewer \e\e\(aqs
ampersand\-nobg\-in\-token on  3.4 & only backgrounds if followed by a separating character
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here is what they mean:
.INDENT 0.0
.IP \(bu 2
\fBstderr\-nocaret\fP was introduced in fish 3.0 (and made the default in 3.3). It makes \fB^\fP an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use \fB2>\fP instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a \fBno\-stderr\-nocaret\fP value will simply be ignored.
.IP \(bu 2
\fBqmark\-noglob\fP was also introduced in fish 3.0. It makes \fB?\fP an ordinary character instead of a single\-character glob. Use a \fB*\fP instead (which will match multiple characters) or find other ways to match files like \fBfind\fP\&.
.IP \(bu 2
\fBregex\-easyesc\fP was introduced in 3.1. It makes it so the replacement expression in \fBstring replace \-r\fP does one fewer round of escaping. Before, to escape a backslash you would have to use \fBstring replace \-ra \(aq([ab])\(aq \(aq\e\e\e\e\e\e\e\e$1\(aq\fP\&. After, just \fB\(aq\e\e\e\e$1\(aq\fP is enough. Check your \fBstring replace\fP calls if you use this anywhere.
.IP \(bu 2
\fBampersand\-nobg\-in\-token\fP was introduced in fish 3.4. It makes it so a \fB&\fP i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the \fB&\fP\&. This is recommended formatting anyway, and \fBfish_indent\fP will have done it for you already.
.UNINDENT
.sp
These changes are introduced off by default. They can be enabled on a per session basis:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> fish \-\-features qmark\-noglob,regex\-easyesc
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
or opted into globally for a user:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
> set \-U fish_features regex\-easyesc qmark\-noglob
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Features will only be set on startup, so this variable will only take effect if it is universal or exported.
.sp
You can also use the version as a group, so \fB3.0\fP is equivalent to \(dqstderr\-nocaret\(dq and \(dqqmark\-noglob\(dq. Instead of a version, the special group \fBall\fP enables all features.
.sp
Prefixing a feature with \fBno\-\fP turns it off instead. E.g. to reenable the \fB?\fP single\-character glob:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
set \-Ua fish_features no\-qmark\-noglob
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Currently, the following features are enabled by default:
.INDENT 0.0
.IP \(bu 2
stderr\-nocaret \- \fB^\fP no longer redirects stderr, use \fB2>\fP\&. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.
.IP \(bu 2
regex\-easyesc \- \fBstring replace \-r\fP requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.
.IP \(bu 2
ampersand\-nobg\-in\-token \- \fB&\fP in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.
.UNINDENT
.SH EVENT HANDLERS
.sp
When defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:
.INDENT 0.0
.IP \(bu 2
When a signal is delivered
.IP \(bu 2
When a job exits
.IP \(bu 2
When the value of a variable is updated
.IP \(bu 2
When the prompt is about to be shown
.UNINDENT
.sp
Example:
.sp
To specify a signal handler for the WINCH signal, write:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function my_signal_handler \-\-on\-signal WINCH
    echo Got WINCH signal!
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Fish already the following named events for the \fB\-\-on\-event\fP switch:
.INDENT 0.0
.IP \(bu 2
\fBfish_prompt\fP is emitted whenever a new fish prompt is about to be displayed.
.IP \(bu 2
\fBfish_preexec\fP is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.
.IP \(bu 2
\fBfish_posterror\fP is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.
.IP \(bu 2
\fBfish_postexec\fP is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.
.IP \(bu 2
\fBfish_exit\fP is emitted right before fish exits.
.IP \(bu 2
\fBfish_cancel\fP is emitted when a commandline is cleared.
.UNINDENT
.sp
Events can be fired with the \fI\%emit\fP command, and do not have to be defined before. The names just need to match. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
function handler \-\-on\-event imdone
    echo generator is done $argv
end

function generator
    sleep 1
    # The \(dqimdone\(dq is the name of the event
    # the rest is the arguments to pass to the handler
    emit imdone with $argv
end
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.
.sp
Please note that event handlers only become active when a function is loaded, which means you need to otherwise \fI\%source\fP or execute a function instead of relying on \fI\%autoloading\fP\&. One approach is to put it into your \fI\%configuration file\fP\&.
.sp
For more information on how to define new event handlers, see the documentation for the \fI\%function\fP command.
.SH DEBUGGING FISH SCRIPTS
.sp
Fish includes basic built\-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using \fI\%printf\fP and \fI\%set\fP\&. As another example, you can run \fI\%status print\-stack\-trace\fP to see how the current breakpoint was reached. To resume normal execution of the script, simply type \fI\%exit\fP or \fBControl\fP+\fBD\fP\&.
.sp
To start a debug session simply insert the \fI\%builtin command\fP \fBbreakpoint\fP at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the \fBTRAP\fP signal is to call this builtin, meaning a running script can be actively debugged by sending it the \fBTRAP\fP signal (\fBkill \-s TRAP <PID>\fP). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the \fBfunced\fP function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.
.sp
Another way to debug script issues is to set the \fI\%fish_trace\fP variable, e.g. \fBfish_trace=1 fish_prompt\fP to see which commands fish executes when running the \fI\%fish_prompt\fP function.
.sp
If you specifically want to debug performance issues, \fBfish\fP can be run with the \fB\-\-profile /path/to/profile.log\fP option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See \fI\%fish\fP for more information.
.SH AUTHOR
fish-shell developers
.SH COPYRIGHT
2023, fish-shell developers
.\" Generated by docutils manpage writer.
.
